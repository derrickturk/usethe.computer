<!DOCTYPE html>
<html>
    <head>
        <!--#set var="title" value="Irregular Expressions, Revisited" -->
        <!--#include file="/include/head.html" -->
    </head>
    <body>
        <!--#include file="/include/before.html" -->
        <h2 class="title">Irregular Expressions, Revisited</h2>
        <h3 class="date">2020-06-26</h3>

<p><a href="https://usethe.computer/posts/18-irregular-expressions.html">Last time</a>, we used a minimalist parser combinator library to build a parser for an oddly familiar language called OBAN.</p>
<p>As a refresher, the full grammar of OBAN is:</p>
<pre class="ebnf"><code>digit = &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; | &quot;8&quot; | &quot;9&quot;;
number = digit, { digit };
any_character = ? any UTF-8 code point ?
string = &quot;&lt;&lt;&quot;, { (any_character - &quot;&gt;&quot;) | &quot;^&gt;&quot; }, &quot;&gt;&gt;&quot;
triboolean = &quot;True&quot; | &quot;False&quot; | &quot;FileNotFound&quot;;
expression = number | string | triboolean | congregation | callout
congregation = &quot;(&quot;, [ expression, { &quot;,&quot;, expression } ], &quot;)&quot;
callout = &quot;{&quot;, [ string, &quot;!&quot;, expression, { &quot;&amp;&quot;, string, &quot;!&quot;, expression } ], &quot;}&quot;</code></pre>
<p>The goal of our parser is to process OBAN documents like:</p>
<pre><code>{ &lt;&lt;first&gt;&gt; ! (1, FileNotFound)
&amp; &lt;&lt;second&gt;&gt; ! &lt;&lt;some &lt;&lt;text^&gt;^&gt;&gt;&gt;
&amp; &lt;&lt;third&gt;&gt; ! { &lt;&lt;nested&gt;&gt; ! True }
}</code></pre>
<p>And produce corresponding Python structures like<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>:</p>
<pre class="sourceCode python" id="cb3"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" data-line-number="1">{ <span class="st">&#39;first&#39;</span>: [<span class="dv">1</span>, FileNotFound]</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">, <span class="st">&#39;second&#39;</span>: <span class="st">&#39;some &lt;&lt;text&gt;&gt;&#39;</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">, <span class="st">&#39;third&#39;</span>: { <span class="st">&#39;nested&#39;</span>: <span class="va">True</span> }</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">}</a></code></pre>
<p>We’ll re-use the imports and OBAN data type definitions from last time:</p>
<pre class="sourceCode python" id="cb4"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="im">import</span> sys</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="im">from</span> enum <span class="im">import</span> Enum, auto</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="im">from</span> typing <span class="im">import</span> Any, Callable, Dict, List, NamedTuple, Tuple, TypeVar, Union</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="co"># OBAN AST definitions</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="kw">class</span> TriBool(Enum):</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">    FALSE <span class="op">=</span> auto()</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">    TRUE <span class="op">=</span> auto()</a>
<a class="sourceLine" id="cb4-10" data-line-number="10">    FILENOTFOUND <span class="op">=</span> auto()</a>
<a class="sourceLine" id="cb4-11" data-line-number="11"></a>
<a class="sourceLine" id="cb4-12" data-line-number="12"><span class="kw">class</span> Expression:</a>
<a class="sourceLine" id="cb4-13" data-line-number="13">    Wrappable <span class="op">=</span> Union[</a>
<a class="sourceLine" id="cb4-14" data-line-number="14">        <span class="bu">int</span>,</a>
<a class="sourceLine" id="cb4-15" data-line-number="15">        <span class="bu">str</span>,</a>
<a class="sourceLine" id="cb4-16" data-line-number="16">        TriBool,</a>
<a class="sourceLine" id="cb4-17" data-line-number="17">        List[<span class="st">&#39;Expression&#39;</span>],</a>
<a class="sourceLine" id="cb4-18" data-line-number="18">        Dict[<span class="bu">str</span>, <span class="st">&#39;Expression&#39;</span>]</a>
<a class="sourceLine" id="cb4-19" data-line-number="19">    ]</a>
<a class="sourceLine" id="cb4-20" data-line-number="20"></a>
<a class="sourceLine" id="cb4-21" data-line-number="21">    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, value: Wrappable):</a>
<a class="sourceLine" id="cb4-22" data-line-number="22">        <span class="va">self</span>.value <span class="op">=</span> value</a>
<a class="sourceLine" id="cb4-23" data-line-number="23"></a>
<a class="sourceLine" id="cb4-24" data-line-number="24">    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb4-25" data-line-number="25">        <span class="cf">return</span> <span class="ss">f&#39;Expression(</span><span class="sc">{</span><span class="bu">repr</span>(<span class="va">self</span>.value)<span class="sc">}</span><span class="ss">)&#39;</span></a></code></pre>
<h3 class="title" id="the-trouble-with-maybe">The Trouble With Maybe</h3>
<p>The biggest problem with our previous parser is that it produces extremely unhelpful error messages, due to the use of the <a href="https://en.wikipedia.org/wiki/Option_type">option monad</a> to represent parse failure. This is probably fine for a parser which runs as part of an automated toolchain and processes almost-always-valid input, but is completely unacceptable for a user-facing tool. We additionally worried about the performance impact of making copies of the input (sub)string when advancing the parser.</p>
<p>We’ll address both of these concerns, while making only minimal changes to the parser’s structure, by tweaking the “base monad” on which it's built. In other words, we’ll change what it means to chain parsers together.</p>
<p>Instead of representing parsers by functions which take input and produce either the remaining input and a parsed value, or <code>None</code>, we’ll represent parsers by functions which take input and produce either the remaining input and the parsed value, or a structured error value conveying more information about what went wrong. We’ll also slightly extend the notion of “input”; instead of copying the remaining input when returning from each parser, we’ll keep the original input string fixed, but additionally pass our current position in it between parsers. This extra state can be passed around in a purely functional way, and enables us to avoid string copies and improve performance.</p>
<p>Let’s define types for our parser state and structured errors, and update the definition of the types of parsers themselves.</p>
<pre class="sourceCode python" id="cb5"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co"># this time, we&#39;ll parse into a monad with state, context,</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="co">#   and a richer notion of failure</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="kw">class</span> ParserState(NamedTuple):</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    pos: <span class="bu">int</span> <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">    <span class="co"># methods for producing updated states</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">    <span class="kw">def</span> advance(<span class="va">self</span>, chars: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="st">&#39;ParserState&#39;</span>:</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">        <span class="cf">return</span> <span class="va">self</span>._replace(pos <span class="op">=</span> <span class="va">self</span>.pos <span class="op">+</span> chars)</a>
<a class="sourceLine" id="cb5-11" data-line-number="11"></a>
<a class="sourceLine" id="cb5-12" data-line-number="12">    <span class="co"># is the parser at the end of input?</span></a>
<a class="sourceLine" id="cb5-13" data-line-number="13">    <span class="kw">def</span> is_eof(<span class="va">self</span>, <span class="bu">input</span>: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">bool</span>:</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">        <span class="cf">return</span> <span class="va">self</span>.pos <span class="op">&gt;=</span> <span class="bu">len</span>(<span class="bu">input</span>)</a>
<a class="sourceLine" id="cb5-15" data-line-number="15"></a>
<a class="sourceLine" id="cb5-16" data-line-number="16">    <span class="co"># examine the next n chars from the input, starting at pos</span></a>
<a class="sourceLine" id="cb5-17" data-line-number="17">    <span class="kw">def</span> <span class="bu">slice</span>(<span class="va">self</span>, <span class="bu">input</span>: <span class="bu">str</span>, chars: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">str</span>:</a>
<a class="sourceLine" id="cb5-18" data-line-number="18">        <span class="cf">return</span> <span class="bu">input</span>[<span class="va">self</span>.pos : <span class="va">self</span>.pos <span class="op">+</span> chars]</a>
<a class="sourceLine" id="cb5-19" data-line-number="19"></a>
<a class="sourceLine" id="cb5-20" data-line-number="20">    <span class="co"># fail at the current pos with a given &#39;expected&#39; message</span></a>
<a class="sourceLine" id="cb5-21" data-line-number="21">    <span class="kw">def</span> fail(<span class="va">self</span>, expected: <span class="bu">str</span>, committed: <span class="bu">bool</span> <span class="op">=</span> <span class="va">False</span>) <span class="op">-&gt;</span> <span class="st">&#39;ParseError&#39;</span>:</a>
<a class="sourceLine" id="cb5-22" data-line-number="22">        <span class="cf">return</span> ParseError(<span class="va">self</span>.pos, expected, committed)</a>
<a class="sourceLine" id="cb5-23" data-line-number="23"></a>
<a class="sourceLine" id="cb5-24" data-line-number="24"><span class="kw">class</span> ParseError(NamedTuple):</a>
<a class="sourceLine" id="cb5-25" data-line-number="25">    pos: <span class="bu">int</span></a>
<a class="sourceLine" id="cb5-26" data-line-number="26">    expected: <span class="bu">str</span></a>
<a class="sourceLine" id="cb5-27" data-line-number="27">    committed: <span class="bu">bool</span> <span class="op">=</span> <span class="va">False</span> <span class="co"># is this error &quot;un-backtrackable&quot;? see `alt`.</span></a>
<a class="sourceLine" id="cb5-28" data-line-number="28"></a>
<a class="sourceLine" id="cb5-29" data-line-number="29">_T <span class="op">=</span> TypeVar(<span class="st">&#39;_T&#39;</span>)</a>
<a class="sourceLine" id="cb5-30" data-line-number="30">ParseResult <span class="op">=</span> Union[Tuple[_T, ParserState], ParseError]</a>
<a class="sourceLine" id="cb5-31" data-line-number="31">Parser <span class="op">=</span> Callable[[<span class="bu">str</span>, ParserState], ParseResult[_T]]</a>
<a class="sourceLine" id="cb5-32" data-line-number="32"></a>
<a class="sourceLine" id="cb5-33" data-line-number="33"><span class="co"># a parser which can&#39;t fail</span></a>
<a class="sourceLine" id="cb5-34" data-line-number="34">InfallibleParser <span class="op">=</span> Callable[[<span class="bu">str</span>, ParserState], Tuple[_T, ParserState]]</a></code></pre>
<p>The parse error type contains the position at which the error occurred, and a textual description of what was expected at that position; this’ll be created by the individual parsers (in some cases, our combinators will be clever enough to write it themselves). There’s also a flag for whether this error is <em>committed</em>, which we’ll discuss in a bit.</p>
<p>The methods on the <code>ParserState</code> class make it simpler to retrieve the next few characters from the input, to advance the parser’s position, to check for end-of-input, and to produce an error at the current position. <code>ParserState</code> is, by design, immutable, so functions like <code>advance</code> produce new state objects rather than mutate the current instance.</p>
<p>Let’s see what the new parser monad looks like in action, by implementing the <code>exactly</code>, <code>eof</code>, and <code>char</code> parsers from before.</p>
<pre class="sourceCode python" id="cb6"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">def</span> exactly(match: <span class="bu">str</span>) <span class="op">-&gt;</span> Parser[<span class="bu">str</span>]:</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">    <span class="kw">def</span> parser(<span class="bu">input</span>: <span class="bu">str</span>, state: ParserState) <span class="op">-&gt;</span> ParseResult[<span class="bu">str</span>]:</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">        <span class="cf">if</span> state.<span class="bu">slice</span>(<span class="bu">input</span>, <span class="bu">len</span>(match)) <span class="op">==</span> match:</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">            <span class="cf">return</span> match, state.advance(<span class="bu">len</span>(match))</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">        <span class="cf">return</span> state.fail(<span class="ss">f&#39;&quot;</span><span class="sc">{</span>match<span class="sc">}</span><span class="ss">&quot;&#39;</span>)</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    <span class="cf">return</span> parser</a>
<a class="sourceLine" id="cb6-7" data-line-number="7"></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">eof: Parser[<span class="va">None</span>]</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">eof <span class="op">=</span> <span class="kw">lambda</span> <span class="bu">input</span>, state: (</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">    (<span class="va">None</span>, state) <span class="cf">if</span> state.is_eof(<span class="bu">input</span>)</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">    <span class="cf">else</span> state.fail(<span class="st">&#39;end of input&#39;</span>)</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">)</a>
<a class="sourceLine" id="cb6-13" data-line-number="13"></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">char: Parser[<span class="bu">str</span>]</a>
<a class="sourceLine" id="cb6-15" data-line-number="15">char <span class="op">=</span> <span class="kw">lambda</span> <span class="bu">input</span>, state: (</a>
<a class="sourceLine" id="cb6-16" data-line-number="16">    (state.<span class="bu">slice</span>(<span class="bu">input</span>, <span class="dv">1</span>), state.advance(<span class="dv">1</span>)) <span class="cf">if</span> <span class="kw">not</span> state.is_eof(<span class="bu">input</span>)</a>
<a class="sourceLine" id="cb6-17" data-line-number="17">    <span class="cf">else</span> state.fail(<span class="st">&#39;any character&#39;</span>)</a>
<a class="sourceLine" id="cb6-18" data-line-number="18">)</a></code></pre>
<p>Instead of “peeling off” the relevant part of the input string, we use the methods on <code>ParserState</code> to advance the current position and view slices as needed (this being Python, the slicing operation does make a copy—in other languages, we might be able to write a “zero-copy” parser using the same idea). When we call the <code>fail</code> method, we provide a string indicating what was expected by the parser.</p>
<p>When we write <code>chars_while</code>, we’ll need to use more explicit manipulation of the current position:</p>
<pre class="sourceCode python" id="cb7"><code class="sourceCode python"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="co"># we could build this with char, but we&#39;ll write it more efficiently by</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="co">#   directly inspecting the input one character at a time</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="kw">def</span> chars_while(p: Callable[[<span class="bu">str</span>], <span class="bu">bool</span>]) <span class="op">-&gt;</span> InfallibleParser[<span class="bu">str</span>]:</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    <span class="kw">def</span> parser(<span class="bu">input</span>: <span class="bu">str</span>, state: ParserState) <span class="op">-&gt;</span> Tuple[<span class="bu">str</span>, ParserState]:</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">        chars: <span class="bu">int</span> <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">        <span class="cf">while</span> state.pos <span class="op">+</span> chars <span class="op">&lt;</span> <span class="bu">len</span>(<span class="bu">input</span>) <span class="kw">and</span> p(<span class="bu">input</span>[state.pos <span class="op">+</span> chars]):</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">            chars <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">        <span class="cf">return</span> state.<span class="bu">slice</span>(<span class="bu">input</span>, chars), state.advance(chars)</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">    <span class="cf">return</span> parser</a>
<a class="sourceLine" id="cb7-10" data-line-number="10"></a>
<a class="sourceLine" id="cb7-11" data-line-number="11">whitespace: Parser[<span class="bu">str</span>]</a>
<a class="sourceLine" id="cb7-12" data-line-number="12">whitespace <span class="op">=</span> chars_while(<span class="bu">str</span>.isspace)</a></code></pre>
<p>Many of our basic combinators remain nearly unchanged (and our problems with giving types to the variadic combinators also remain):</p>
<pre class="sourceCode python" id="cb8"><code class="sourceCode python"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co"># combinators work like before - but there will be a little more plumbing</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="co">#   in the error case</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">_U <span class="op">=</span> TypeVar(<span class="st">&#39;_U&#39;</span>)</a>
<a class="sourceLine" id="cb8-4" data-line-number="4"></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="co"># map a function over a parser&#39;s result, if it succeeds</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6"><span class="kw">def</span> pmap(f: Callable[[_T], _U], p: Parser[_T]) <span class="op">-&gt;</span> Parser[_U]:</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    <span class="kw">def</span> parser(<span class="bu">input</span>: <span class="bu">str</span>, state: ParserState) <span class="op">-&gt;</span> ParseResult[_U]:</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">        res <span class="op">=</span> p(<span class="bu">input</span>, state)</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">        <span class="cf">if</span> <span class="bu">isinstance</span>(res, ParseError):</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">            <span class="cf">return</span> res</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">        x, new_state <span class="op">=</span> res</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">        <span class="cf">return</span> f(x), new_state</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">    <span class="cf">return</span> parser</a>
<a class="sourceLine" id="cb8-14" data-line-number="14"></a>
<a class="sourceLine" id="cb8-15" data-line-number="15"><span class="co"># a parser which always succeeds by producing a constant</span></a>
<a class="sourceLine" id="cb8-16" data-line-number="16"><span class="kw">def</span> pure(x: _T) <span class="op">-&gt;</span> InfallibleParser[_T]:</a>
<a class="sourceLine" id="cb8-17" data-line-number="17">    <span class="cf">return</span> <span class="kw">lambda</span> _, state: (x, state)</a>
<a class="sourceLine" id="cb8-18" data-line-number="18"></a>
<a class="sourceLine" id="cb8-19" data-line-number="19"><span class="co"># the opposite - a parser which always fails (with a given &quot;expected&quot; message)</span></a>
<a class="sourceLine" id="cb8-20" data-line-number="20"><span class="kw">def</span> fail(expected: <span class="bu">str</span>) <span class="op">-&gt;</span> Parser[_T]:</a>
<a class="sourceLine" id="cb8-21" data-line-number="21">    <span class="cf">return</span> <span class="kw">lambda</span> _, state: state.fail(expected)</a>
<a class="sourceLine" id="cb8-22" data-line-number="22"></a>
<a class="sourceLine" id="cb8-23" data-line-number="23"><span class="co"># replace a successful result by a constant</span></a>
<a class="sourceLine" id="cb8-24" data-line-number="24"><span class="kw">def</span> cmap(x: _T, p: Parser[_U]) <span class="op">-&gt;</span> Parser[_T]:</a>
<a class="sourceLine" id="cb8-25" data-line-number="25">    <span class="cf">return</span> pmap(<span class="kw">lambda</span> _: x, p)</a>
<a class="sourceLine" id="cb8-26" data-line-number="26"></a>
<a class="sourceLine" id="cb8-27" data-line-number="27"><span class="co"># these are harder to type in Python - we can do them for the fixed-arity case,</span></a>
<a class="sourceLine" id="cb8-28" data-line-number="28"><span class="co">#   but it&#39;s just too convenient to let these take *args</span></a>
<a class="sourceLine" id="cb8-29" data-line-number="29"></a>
<a class="sourceLine" id="cb8-30" data-line-number="30"><span class="co"># chain multiple parsers together and produce a tuple of their results,</span></a>
<a class="sourceLine" id="cb8-31" data-line-number="31"><span class="co">#   if all succeed</span></a>
<a class="sourceLine" id="cb8-32" data-line-number="32"><span class="kw">def</span> chain(<span class="op">*</span>parsers: Parser[Any]) <span class="op">-&gt;</span> Parser[Tuple[Any, ...]]:</a>
<a class="sourceLine" id="cb8-33" data-line-number="33">    <span class="kw">def</span> parser(<span class="bu">input</span>: <span class="bu">str</span>, state: ParserState) <span class="op">-&gt;</span> ParseResult[Tuple[Any, ...]]:</a>
<a class="sourceLine" id="cb8-34" data-line-number="34">        results <span class="op">=</span> <span class="bu">list</span>()</a>
<a class="sourceLine" id="cb8-35" data-line-number="35">        <span class="cf">for</span> p <span class="kw">in</span> parsers:</a>
<a class="sourceLine" id="cb8-36" data-line-number="36">            res <span class="op">=</span> p(<span class="bu">input</span>, state)</a>
<a class="sourceLine" id="cb8-37" data-line-number="37">            <span class="cf">if</span> <span class="bu">isinstance</span>(res, ParseError):</a>
<a class="sourceLine" id="cb8-38" data-line-number="38">                <span class="cf">return</span> res</a>
<a class="sourceLine" id="cb8-39" data-line-number="39">            val, state <span class="op">=</span> res</a>
<a class="sourceLine" id="cb8-40" data-line-number="40">            results.append(val)</a>
<a class="sourceLine" id="cb8-41" data-line-number="41">        <span class="cf">return</span> <span class="bu">tuple</span>(results), state</a>
<a class="sourceLine" id="cb8-42" data-line-number="42">    <span class="cf">return</span> parser</a></code></pre>
<h3 class="title" id="commitment-issues">Commitment Issues</h3>
<p>Let’s now consider the <code>alt</code> combinator in the context of our new parsing monad. Remember, our goal is to provide the richest possible information on parse errors. In the old, <code>None</code>-based system, it didn’t really matter what we did in the error case: either at least one parser succeeded, or none did. Now, though, we have a problem: when <code>alt</code> fails because no sub-parser succeeded, where should we say the error occurred, and what should we say was expected? The straightforward answer is: the error occurred at the position where the <code>alt</code> parser was run, and the “expected” message can be built by concatenating a list of all the sub-parser expectations. This works well—to a point.</p>
<p>Consider the following (malformed) OBAN expression: <code>(1, 2, &lt;&lt;half-open string)</code>. Obviously, this isn’t valid because there’s an unclosed string (no <code>&gt;&gt;</code>). However, the implementation we just described would produce an error like “at position 0, expected: digit, ‘True’, ‘False’, ‘FileNotFound’, ‘&lt;&lt;’, ‘(’, or ‘{’”.<br />
Why? Because the string parser’s reported failure, inside an <code>alt</code>-based expression parser called as part of the congregation parser, would cause the expression parser to fail, which would cause the congregation parser to fail, which in turn would cause the outer <code>alt</code>-based expression parser to fail. We’d report said failure at the position it began running (that is, the first character), and the “expected” message would come from the various sub-parsers of the outermost expression parser.</p>
<p>This is a subtle point but an important one to consider when designing human-friendly parsers. Naïve backtracking often results in overly general error messages. What we’ve missed is this: there are certain points in a parse where we know, for certain, that we are “locked in” or <em>committed</em> to one branch of an <code>alt</code>, and don’t want to backtrack out of it.</p>
<p>When, while parsing an expression, we see an opening ‘<code>(</code>’ character, we know that we are now parsing a congregation. If we subsequently fail, say, because of a missing ‘<code>,</code>’ separator character, we want to report that error all the way back to the top-level parser. (This is analogous to the “cut” operator in Prolog, and some combinator libraries use the name “cut” for this technique.) In our parser, we’ll implement this by providing a <code>commit</code> combinator which takes an existing parser and produces a “non-backtrackable” version of it. Under the hood, this will work by setting the <code>committed</code> flag on parse errors, which our <code>alt</code> combinator will recognize:</p>
<pre class="sourceCode python" id="cb9"><code class="sourceCode python"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="co"># run multiple parsers, recovering from errors, until one succeeds;</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="co">#   fail if all parsers fail</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="co"># this parser introduces a new issue: &quot;unbacktrackable&quot; errors</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="co"># we usually want `alt` to backtrack when a sub-parser fails, so that it can</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="co">#   try the next parser in the sequence without consuming any input.</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6"><span class="co"># however, sometimes a sub-parser &quot;knows&quot; that the expected grammar is locked</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7"><span class="co">#   in, and we want `alt` to fail if that parser fails.</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8"><span class="co"># consider parsing Python&#39;s `x if y else z`: once we see `if`, we know that</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9"><span class="co">#   we&#39;re inside a conditional expression - if we get a subsequent parse error,</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10"><span class="co">#   we would not want to go back and try parsing the whole thing as, say, a list</span></a>
<a class="sourceLine" id="cb9-11" data-line-number="11"><span class="co">#   comprehension!</span></a>
<a class="sourceLine" id="cb9-12" data-line-number="12"><span class="kw">def</span> alt(<span class="op">*</span>parsers: Parser[Any]) <span class="op">-&gt;</span> Parser[Any]:</a>
<a class="sourceLine" id="cb9-13" data-line-number="13">    <span class="kw">def</span> parser(<span class="bu">input</span>: <span class="bu">str</span>, state: ParserState) <span class="op">-&gt;</span> ParseResult[Any]:</a>
<a class="sourceLine" id="cb9-14" data-line-number="14">        expected: List[<span class="bu">str</span>] <span class="op">=</span> <span class="bu">list</span>()</a>
<a class="sourceLine" id="cb9-15" data-line-number="15">        <span class="cf">for</span> p <span class="kw">in</span> parsers:</a>
<a class="sourceLine" id="cb9-16" data-line-number="16">            res <span class="op">=</span> p(<span class="bu">input</span>, state)</a>
<a class="sourceLine" id="cb9-17" data-line-number="17">            <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(res, ParseError):</a>
<a class="sourceLine" id="cb9-18" data-line-number="18">                <span class="cf">return</span> res</a>
<a class="sourceLine" id="cb9-19" data-line-number="19">            <span class="cf">if</span> res.committed:</a>
<a class="sourceLine" id="cb9-20" data-line-number="20">                <span class="cf">return</span> res <span class="co"># these errors can&#39;t be backtracked</span></a>
<a class="sourceLine" id="cb9-21" data-line-number="21">            expected.append(res.expected)</a>
<a class="sourceLine" id="cb9-22" data-line-number="22">        <span class="co"># take a crack at an &quot;expected&quot; message by combining sub-parser messages</span></a>
<a class="sourceLine" id="cb9-23" data-line-number="23">        <span class="cf">return</span> state.fail(<span class="st">&#39;, or &#39;</span>.join(expected))</a>
<a class="sourceLine" id="cb9-24" data-line-number="24">    <span class="cf">return</span> parser</a>
<a class="sourceLine" id="cb9-25" data-line-number="25"></a>
<a class="sourceLine" id="cb9-26" data-line-number="26"><span class="co"># run a parser, but make any errors &quot;committed&quot;/&quot;unbacktrackable&quot;</span></a>
<a class="sourceLine" id="cb9-27" data-line-number="27"><span class="kw">def</span> commit(p: Parser[_T]) <span class="op">-&gt;</span> Parser[_T]:</a>
<a class="sourceLine" id="cb9-28" data-line-number="28">    <span class="kw">def</span> parser(<span class="bu">input</span>: <span class="bu">str</span>, state: ParserState) <span class="op">-&gt;</span> ParseResult:</a>
<a class="sourceLine" id="cb9-29" data-line-number="29">        res <span class="op">=</span> p(<span class="bu">input</span>, state)</a>
<a class="sourceLine" id="cb9-30" data-line-number="30">        <span class="cf">if</span> <span class="bu">isinstance</span>(res, ParseError):</a>
<a class="sourceLine" id="cb9-31" data-line-number="31">            <span class="cf">return</span> res._replace(committed<span class="op">=</span><span class="va">True</span>)</a>
<a class="sourceLine" id="cb9-32" data-line-number="32">        <span class="cf">return</span> res</a>
<a class="sourceLine" id="cb9-33" data-line-number="33">    <span class="cf">return</span> parser</a>
<a class="sourceLine" id="cb9-34" data-line-number="34"></a>
<a class="sourceLine" id="cb9-35" data-line-number="35"><span class="co"># capture zero or more repetitions of a parser</span></a>
<a class="sourceLine" id="cb9-36" data-line-number="36"><span class="co"># the end-of-loop condition is a form of backtracking, so we need to check</span></a>
<a class="sourceLine" id="cb9-37" data-line-number="37"><span class="co">#   for a committed error</span></a>
<a class="sourceLine" id="cb9-38" data-line-number="38"><span class="kw">def</span> many(p: Parser[_T]) <span class="op">-&gt;</span> Parser[List[_T]]:</a>
<a class="sourceLine" id="cb9-39" data-line-number="39">    <span class="kw">def</span> parser(<span class="bu">input</span>: <span class="bu">str</span>, state: ParserState) <span class="op">-&gt;</span> ParseResult[List[_T]]:</a>
<a class="sourceLine" id="cb9-40" data-line-number="40">        results: List[_T] <span class="op">=</span> <span class="bu">list</span>()</a>
<a class="sourceLine" id="cb9-41" data-line-number="41">        <span class="cf">while</span> <span class="va">True</span>:</a>
<a class="sourceLine" id="cb9-42" data-line-number="42">            res <span class="op">=</span> p(<span class="bu">input</span>, state)</a>
<a class="sourceLine" id="cb9-43" data-line-number="43">            <span class="cf">if</span> <span class="bu">isinstance</span>(res, ParseError):</a>
<a class="sourceLine" id="cb9-44" data-line-number="44">                <span class="cf">if</span> res.committed:</a>
<a class="sourceLine" id="cb9-45" data-line-number="45">                    <span class="cf">return</span> res</a>
<a class="sourceLine" id="cb9-46" data-line-number="46">                <span class="cf">return</span> results, state</a>
<a class="sourceLine" id="cb9-47" data-line-number="47">            val, state <span class="op">=</span> res</a>
<a class="sourceLine" id="cb9-48" data-line-number="48">            results.append(val)</a>
<a class="sourceLine" id="cb9-49" data-line-number="49">    <span class="cf">return</span> parser</a>
<a class="sourceLine" id="cb9-50" data-line-number="50"></a>
<a class="sourceLine" id="cb9-51" data-line-number="51"><span class="co"># we can use alt to define an &quot;optional&quot; parser combinator, which allows but does</span></a>
<a class="sourceLine" id="cb9-52" data-line-number="52"><span class="co">#   not require its base parser to match</span></a>
<a class="sourceLine" id="cb9-53" data-line-number="53"><span class="kw">def</span> optional(p: Parser[_T]) <span class="op">-&gt;</span> Parser[Union[_T, <span class="va">None</span>]]:</a>
<a class="sourceLine" id="cb9-54" data-line-number="54">    <span class="cf">return</span> alt(p, pure(<span class="va">None</span>))</a></code></pre>
<p>We also had to recognize “committed” errors in <code>many</code>, because it too has backtracking behavior when it encounters the first parse error.</p>
<p>Our additional combinators look much the same as before; in some cases the implementation is identical.</p>
<pre class="sourceCode python" id="cb10"><code class="sourceCode python"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="co"># finally, a way to &quot;decide&quot; the next parser based on</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="co">#   the result of the previous - this is what makes Parser a monad</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="kw">def</span> bind(p: Parser[_T], f: Callable[[_T], Parser[_U]]) <span class="op">-&gt;</span> Parser[_U]:</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">    <span class="kw">def</span> parser(<span class="bu">input</span>: <span class="bu">str</span>, state: ParserState) <span class="op">-&gt;</span> ParseResult[_U]:</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">        res <span class="op">=</span> p(<span class="bu">input</span>, state)</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">        <span class="cf">if</span> <span class="bu">isinstance</span>(res, ParseError):</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">            <span class="cf">return</span> res</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">        x, state <span class="op">=</span> res</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">        <span class="cf">return</span> f(x)(<span class="bu">input</span>, state)</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">    <span class="cf">return</span> parser</a>
<a class="sourceLine" id="cb10-11" data-line-number="11"></a>
<a class="sourceLine" id="cb10-12" data-line-number="12"><span class="co"># we can use bind to build some interesting extensions to previous</span></a>
<a class="sourceLine" id="cb10-13" data-line-number="13"><span class="co">#   parsers</span></a>
<a class="sourceLine" id="cb10-14" data-line-number="14"></a>
<a class="sourceLine" id="cb10-15" data-line-number="15"><span class="co"># like chars_while, but requires there to be at least one matching char</span></a>
<a class="sourceLine" id="cb10-16" data-line-number="16"><span class="co"># rather than &quot;guess&quot; an expected message, take it as an argument</span></a>
<a class="sourceLine" id="cb10-17" data-line-number="17"><span class="kw">def</span> chars_while1(p: Callable[[<span class="bu">str</span>], <span class="bu">bool</span>], expected: <span class="bu">str</span>) <span class="op">-&gt;</span> Parser[<span class="bu">str</span>]:</a>
<a class="sourceLine" id="cb10-18" data-line-number="18">    <span class="cf">return</span> bind(chars_while(p), <span class="kw">lambda</span> c: (</a>
<a class="sourceLine" id="cb10-19" data-line-number="19">        pure(c) <span class="cf">if</span> <span class="bu">len</span>(c) <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> fail(expected)</a>
<a class="sourceLine" id="cb10-20" data-line-number="20">    ))</a>
<a class="sourceLine" id="cb10-21" data-line-number="21"></a>
<a class="sourceLine" id="cb10-22" data-line-number="22"><span class="co"># use it to build a &quot;run of digits&quot; parser</span></a>
<a class="sourceLine" id="cb10-23" data-line-number="23">digits: Parser[<span class="bu">str</span>]</a>
<a class="sourceLine" id="cb10-24" data-line-number="24">digits <span class="op">=</span> chars_while1(<span class="bu">str</span>.isdigit, <span class="st">&#39;digits&#39;</span>)</a>
<a class="sourceLine" id="cb10-25" data-line-number="25"></a>
<a class="sourceLine" id="cb10-26" data-line-number="26"><span class="co"># use it to build an &quot;unsigned integer&quot; parser</span></a>
<a class="sourceLine" id="cb10-27" data-line-number="27">integer: Parser[<span class="bu">int</span>]</a>
<a class="sourceLine" id="cb10-28" data-line-number="28">integer <span class="op">=</span> pmap(<span class="bu">int</span>, digits)</a>
<a class="sourceLine" id="cb10-29" data-line-number="29"></a>
<a class="sourceLine" id="cb10-30" data-line-number="30"><span class="co"># capture one or more repetitions of a parser</span></a>
<a class="sourceLine" id="cb10-31" data-line-number="31"><span class="kw">def</span> some(p: Parser[_T], expected: <span class="bu">str</span>) <span class="op">-&gt;</span> Parser[List[_T]]:</a>
<a class="sourceLine" id="cb10-32" data-line-number="32">    <span class="cf">return</span> bind(many(p), <span class="kw">lambda</span> c: (</a>
<a class="sourceLine" id="cb10-33" data-line-number="33">        pure(c) <span class="cf">if</span> <span class="bu">len</span>(c) <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> fail(expected)</a>
<a class="sourceLine" id="cb10-34" data-line-number="34">    ))</a>
<a class="sourceLine" id="cb10-35" data-line-number="35"></a>
<a class="sourceLine" id="cb10-36" data-line-number="36"><span class="co"># now we can start building some more interesting combinators</span></a>
<a class="sourceLine" id="cb10-37" data-line-number="37"></a>
<a class="sourceLine" id="cb10-38" data-line-number="38"><span class="co"># mypy hates type-checking lambdas as arguments to pmap, so we&#39;ll need some</span></a>
<a class="sourceLine" id="cb10-39" data-line-number="39"><span class="co">#   tuple-extractor functions</span></a>
<a class="sourceLine" id="cb10-40" data-line-number="40"><span class="kw">def</span> first(t: Tuple[Any, ...]) <span class="op">-&gt;</span> Any:</a>
<a class="sourceLine" id="cb10-41" data-line-number="41">    <span class="cf">return</span> t[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb10-42" data-line-number="42"></a>
<a class="sourceLine" id="cb10-43" data-line-number="43"><span class="kw">def</span> second(t: Tuple[Any, ...]) <span class="op">-&gt;</span> Any:</a>
<a class="sourceLine" id="cb10-44" data-line-number="44">    <span class="cf">return</span> t[<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb10-45" data-line-number="45"></a>
<a class="sourceLine" id="cb10-46" data-line-number="46"><span class="co"># &quot;only&quot; p - match what p matches, then insist on end-of-input</span></a>
<a class="sourceLine" id="cb10-47" data-line-number="47"><span class="kw">def</span> only(p: Parser[_T]) <span class="op">-&gt;</span> Parser[_T]:</a>
<a class="sourceLine" id="cb10-48" data-line-number="48">    <span class="cf">return</span> pmap(first, chain(p, eof))</a>
<a class="sourceLine" id="cb10-49" data-line-number="49"></a>
<a class="sourceLine" id="cb10-50" data-line-number="50"><span class="co"># match p, followed by optional whitespace</span></a>
<a class="sourceLine" id="cb10-51" data-line-number="51"><span class="kw">def</span> lexeme(p: Parser[_T]) <span class="op">-&gt;</span> Parser[_T]:</a>
<a class="sourceLine" id="cb10-52" data-line-number="52">    <span class="cf">return</span> pmap(first, chain(p, whitespace))</a>
<a class="sourceLine" id="cb10-53" data-line-number="53"></a>
<a class="sourceLine" id="cb10-54" data-line-number="54"><span class="co"># match zero or more p, separated by sep</span></a>
<a class="sourceLine" id="cb10-55" data-line-number="55"><span class="kw">def</span> sep_by(p: Parser[_T], sep: Parser[_U]) <span class="op">-&gt;</span> Parser[List[_T]]:</a>
<a class="sourceLine" id="cb10-56" data-line-number="56">    <span class="co"># mypy hates this thing&#39;s type</span></a>
<a class="sourceLine" id="cb10-57" data-line-number="57">    <span class="co"># it should be:</span></a>
<a class="sourceLine" id="cb10-58" data-line-number="58">    <span class="co"># def extract(t: Union[Tuple[_T, List[Tuple[_U, _T]]], None]) -&gt; List[_T]:</span></a>
<a class="sourceLine" id="cb10-59" data-line-number="59">    <span class="co"># but that fails inference when we use it as an argument to pmap</span></a>
<a class="sourceLine" id="cb10-60" data-line-number="60">    <span class="kw">def</span> extract(t):</a>
<a class="sourceLine" id="cb10-61" data-line-number="61">        <span class="cf">if</span> t <span class="kw">is</span> <span class="va">None</span>:</a>
<a class="sourceLine" id="cb10-62" data-line-number="62">            <span class="cf">return</span> []</a>
<a class="sourceLine" id="cb10-63" data-line-number="63">        <span class="cf">return</span> [t[<span class="dv">0</span>]] <span class="op">+</span> [u[<span class="dv">1</span>] <span class="cf">for</span> u <span class="kw">in</span> t[<span class="dv">1</span>]]</a>
<a class="sourceLine" id="cb10-64" data-line-number="64">    <span class="cf">return</span> pmap(</a>
<a class="sourceLine" id="cb10-65" data-line-number="65">            extract,</a>
<a class="sourceLine" id="cb10-66" data-line-number="66">            optional(chain(p, many(chain(sep, commit(p))))))</a></code></pre>
<p><code>sep_by</code> has an interesting new twist: once we’ve seen a separator, we <code>commit</code> to the subsequent parser: this way we get informative error messages when parsing malformed constructs like <code>(1,2,)</code></p>
<p>We can now (re)write our OBAN-specific parsers. We’ll use <code>commit</code> in key places where we know that the parser should “lock in” to a given construct. For example, once we’ve seen “<code>&lt;&lt;</code>”, we know that we are parsing a string, and should insist on a closing “<code>&gt;&gt;</code>”.</p>
<pre class="sourceCode python" id="cb11"><code class="sourceCode python"><a class="sourceLine" id="cb11-1" data-line-number="1">tribool: Parser[TriBool]</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">tribool <span class="op">=</span> alt(</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    cmap(TriBool.FALSE, exactly(<span class="st">&#39;False&#39;</span>)),</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    cmap(TriBool.TRUE, exactly(<span class="st">&#39;True&#39;</span>)),</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">    cmap(TriBool.FILENOTFOUND, exactly(<span class="st">&#39;FileNotFound&#39;</span>))</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">)</a>
<a class="sourceLine" id="cb11-7" data-line-number="7"></a>
<a class="sourceLine" id="cb11-8" data-line-number="8"><span class="co"># again, mypy isn&#39;t smart enough to follow the type of this &quot;lambda&quot;</span></a>
<a class="sourceLine" id="cb11-9" data-line-number="9"><span class="kw">def</span> _string_extract(t):</a>
<a class="sourceLine" id="cb11-10" data-line-number="10">    _<span class="dv">1</span>, (parts, _<span class="dv">2</span>) <span class="op">=</span> t</a>
<a class="sourceLine" id="cb11-11" data-line-number="11">    <span class="cf">return</span> <span class="st">&#39;&#39;</span>.join(p[<span class="dv">1</span>] <span class="cf">if</span> <span class="bu">isinstance</span>(p, <span class="bu">tuple</span>) <span class="cf">else</span> p <span class="cf">for</span> p <span class="kw">in</span> parts)</a>
<a class="sourceLine" id="cb11-12" data-line-number="12"></a>
<a class="sourceLine" id="cb11-13" data-line-number="13">string: Parser[<span class="bu">str</span>]</a>
<a class="sourceLine" id="cb11-14" data-line-number="14">string <span class="op">=</span> pmap(</a>
<a class="sourceLine" id="cb11-15" data-line-number="15">    _string_extract,</a>
<a class="sourceLine" id="cb11-16" data-line-number="16">    chain(</a>
<a class="sourceLine" id="cb11-17" data-line-number="17">        exactly(<span class="st">&#39;&lt;&lt;&#39;</span>),</a>
<a class="sourceLine" id="cb11-18" data-line-number="18">        commit(chain(</a>
<a class="sourceLine" id="cb11-19" data-line-number="19">            many(alt(</a>
<a class="sourceLine" id="cb11-20" data-line-number="20">                chars_while1(<span class="kw">lambda</span> c: c <span class="op">!=</span> <span class="st">&#39;&gt;&#39;</span> <span class="kw">and</span> c <span class="op">!=</span> <span class="st">&#39;^&#39;</span>,</a>
<a class="sourceLine" id="cb11-21" data-line-number="21">                    <span class="st">&#39;non-escape characters&#39;</span>),</a>
<a class="sourceLine" id="cb11-22" data-line-number="22">                chain(exactly(<span class="st">&#39;^&#39;</span>), char)</a>
<a class="sourceLine" id="cb11-23" data-line-number="23">            )),</a>
<a class="sourceLine" id="cb11-24" data-line-number="24">            exactly(<span class="st">&#39;&gt;&gt;&#39;</span>)</a>
<a class="sourceLine" id="cb11-25" data-line-number="25">        ))</a>
<a class="sourceLine" id="cb11-26" data-line-number="26">    ))</a>
<a class="sourceLine" id="cb11-27" data-line-number="27"></a>
<a class="sourceLine" id="cb11-28" data-line-number="28"><span class="co"># there&#39;s a circular dependency between congregation, callout, and expression</span></a>
<a class="sourceLine" id="cb11-29" data-line-number="29"><span class="co"># we&#39;ll break it in expression, by making it a &quot;proper&quot; function</span></a>
<a class="sourceLine" id="cb11-30" data-line-number="30"><span class="kw">def</span> expression(<span class="bu">input</span>: <span class="bu">str</span>, state: ParserState) <span class="op">-&gt;</span> ParseResult[Expression]:</a>
<a class="sourceLine" id="cb11-31" data-line-number="31">    parser <span class="op">=</span> pmap(</a>
<a class="sourceLine" id="cb11-32" data-line-number="32">        Expression,</a>
<a class="sourceLine" id="cb11-33" data-line-number="33">        lexeme(alt(integer, tribool, string, congregation, callout)))</a>
<a class="sourceLine" id="cb11-34" data-line-number="34">    <span class="cf">return</span> parser(<span class="bu">input</span>, state)</a>
<a class="sourceLine" id="cb11-35" data-line-number="35"></a>
<a class="sourceLine" id="cb11-36" data-line-number="36"><span class="co"># in a lazier world, this would work:</span></a>
<a class="sourceLine" id="cb11-37" data-line-number="37"><span class="co"># expression: Parser[Expression]</span></a>
<a class="sourceLine" id="cb11-38" data-line-number="38"><span class="co"># expression = pmap(</span></a>
<a class="sourceLine" id="cb11-39" data-line-number="39"><span class="co">#     Expression,</span></a>
<a class="sourceLine" id="cb11-40" data-line-number="40"><span class="co">#     lexeme(alt(integer, tribool, string, congregation, callout)))</span></a>
<a class="sourceLine" id="cb11-41" data-line-number="41"></a>
<a class="sourceLine" id="cb11-42" data-line-number="42"><span class="kw">def</span> _congregation_extract(t):</a>
<a class="sourceLine" id="cb11-43" data-line-number="43">    <span class="cf">return</span> t[<span class="dv">1</span>][<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb11-44" data-line-number="44"></a>
<a class="sourceLine" id="cb11-45" data-line-number="45">congregation: Parser[List[Expression]]</a>
<a class="sourceLine" id="cb11-46" data-line-number="46">congregation <span class="op">=</span> pmap(</a>
<a class="sourceLine" id="cb11-47" data-line-number="47">    _congregation_extract,</a>
<a class="sourceLine" id="cb11-48" data-line-number="48">    chain(</a>
<a class="sourceLine" id="cb11-49" data-line-number="49">        lexeme(exactly(<span class="st">&#39;(&#39;</span>)),</a>
<a class="sourceLine" id="cb11-50" data-line-number="50">        commit(chain(</a>
<a class="sourceLine" id="cb11-51" data-line-number="51">            sep_by(expression, lexeme(exactly(<span class="st">&#39;,&#39;</span>))),</a>
<a class="sourceLine" id="cb11-52" data-line-number="52">            lexeme(exactly(<span class="st">&#39;)&#39;</span>))))</a>
<a class="sourceLine" id="cb11-53" data-line-number="53">    ))</a>
<a class="sourceLine" id="cb11-54" data-line-number="54"></a>
<a class="sourceLine" id="cb11-55" data-line-number="55"><span class="kw">def</span> _callout_extract(t):</a>
<a class="sourceLine" id="cb11-56" data-line-number="56">    <span class="cf">return</span> { kv[<span class="dv">0</span>]: kv[<span class="dv">2</span>] <span class="cf">for</span> kv <span class="kw">in</span> t[<span class="dv">1</span>][<span class="dv">0</span>] }</a>
<a class="sourceLine" id="cb11-57" data-line-number="57"></a>
<a class="sourceLine" id="cb11-58" data-line-number="58">callout: Parser[Dict[<span class="bu">str</span>, Expression]]</a>
<a class="sourceLine" id="cb11-59" data-line-number="59">callout <span class="op">=</span> pmap(</a>
<a class="sourceLine" id="cb11-60" data-line-number="60">    _callout_extract,</a>
<a class="sourceLine" id="cb11-61" data-line-number="61">    chain(</a>
<a class="sourceLine" id="cb11-62" data-line-number="62">        lexeme(exactly(<span class="st">&#39;{&#39;</span>)),</a>
<a class="sourceLine" id="cb11-63" data-line-number="63">        commit(chain(</a>
<a class="sourceLine" id="cb11-64" data-line-number="64">            sep_by(chain(</a>
<a class="sourceLine" id="cb11-65" data-line-number="65">                    lexeme(string),</a>
<a class="sourceLine" id="cb11-66" data-line-number="66">                    lexeme(exactly(<span class="st">&#39;!&#39;</span>)),</a>
<a class="sourceLine" id="cb11-67" data-line-number="67">                    expression</a>
<a class="sourceLine" id="cb11-68" data-line-number="68">                ),</a>
<a class="sourceLine" id="cb11-69" data-line-number="69">                lexeme(exactly(<span class="st">&#39;&amp;&#39;</span>))),</a>
<a class="sourceLine" id="cb11-70" data-line-number="70">            lexeme(exactly(<span class="st">&#39;}&#39;</span>))</a>
<a class="sourceLine" id="cb11-71" data-line-number="71">        ))</a>
<a class="sourceLine" id="cb11-72" data-line-number="72">    ))</a>
<a class="sourceLine" id="cb11-73" data-line-number="73"></a>
<a class="sourceLine" id="cb11-74" data-line-number="74"><span class="co"># since `lexeme` skips trailing whitespace, we need to allow leading whitespace</span></a>
<a class="sourceLine" id="cb11-75" data-line-number="75"><span class="co">#   before a document explicitly, then ensure end-of-input</span></a>
<a class="sourceLine" id="cb11-76" data-line-number="76">document: Parser[Expression]</a>
<a class="sourceLine" id="cb11-77" data-line-number="77">document <span class="op">=</span> pmap(second, chain(whitespace, only(expression)))</a>
<a class="sourceLine" id="cb11-78" data-line-number="78"></a>
<a class="sourceLine" id="cb11-79" data-line-number="79"><span class="kw">def</span> main(argv: List[<span class="bu">str</span>]) <span class="op">-&gt;</span> <span class="bu">int</span>:</a>
<a class="sourceLine" id="cb11-80" data-line-number="80">    <span class="cf">for</span> line <span class="kw">in</span> sys.stdin:</a>
<a class="sourceLine" id="cb11-81" data-line-number="81">        res <span class="op">=</span> document(line.rstrip(), ParserState())</a>
<a class="sourceLine" id="cb11-82" data-line-number="82">        <span class="cf">if</span> <span class="bu">isinstance</span>(res, ParseError):</a>
<a class="sourceLine" id="cb11-83" data-line-number="83">            <span class="bu">print</span>(<span class="ss">f&quot;</span><span class="sc">{</span><span class="st">&#39; &#39;</span> <span class="op">*</span> res<span class="sc">.</span>pos<span class="sc">}</span><span class="ss">^ expected: </span><span class="sc">{</span>res<span class="sc">.</span>expected<span class="sc">}</span><span class="ss">&quot;</span>, <span class="bu">file</span><span class="op">=</span>sys.stderr)</a>
<a class="sourceLine" id="cb11-84" data-line-number="84">        <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb11-85" data-line-number="85">            x, _ <span class="op">=</span> res</a>
<a class="sourceLine" id="cb11-86" data-line-number="86">            <span class="bu">print</span>(<span class="ss">f&#39;&gt; </span><span class="sc">{x}</span><span class="ss">&#39;</span>)</a>
<a class="sourceLine" id="cb11-87" data-line-number="87">    <span class="cf">return</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb11-88" data-line-number="88"></a>
<a class="sourceLine" id="cb11-89" data-line-number="89"><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&#39;__main__&#39;</span>:</a>
<a class="sourceLine" id="cb11-90" data-line-number="90">    sys.exit(main(sys.argv))</a></code></pre>
<p>Our <code>main</code> program reads one line at a time and tries to parse it as an OBAN document. In the event of a parse error, we print a caret at the appropriate location and indicate what was expected.</p>
<p>You can see an example interaction below:<br />
<img class="centered" alt="an animated example" src="/images/parser_optim.gif" width="800px"></p>
<p>We’re now much closer to an “industrial grade” parser, with error messages suitable for human users. Many of these ideas are adapted from the excellent work of others on libraries for various languages; <code>commit</code> or “cut” in particular seems to be indpendently re-invented in the course of almost every parser implementation.</p>
<p>The OBAN grammar (<code>oban.ebnf</code>) and updated parser code (<code>oban_pc_improved.py</code>), as well as the previous material, can be viewed at <a href="https://gist.github.com/derrickturk/7ead182081f2ab1b09225fd0c11dbda9">https://gist.github.com/derrickturk/7ead182081f2ab1b09225fd0c11dbda9</a>.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Just as before, we will need some extra object “wrappers” compared to this “ideal” parse tree, due to limitations in <code>mypy</code>’s ability to handle recursive type aliases.<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>

        <!--#include file="/include/after.html" -->
    </body>
</html>
